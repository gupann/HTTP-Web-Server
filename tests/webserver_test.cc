#include "gtest/gtest.h"
#include "session.h" // Include the session header
#include <boost/asio.hpp>
#include <boost/beast/http.hpp>
#include <string>
#include <sstream>

namespace http = boost::beast::http;

// Test fixture for session tests (generated by Gemini 2.5 Pro (Preview))
class SessionTest : public ::testing::Test {
protected:
    boost::asio::io_service io_service_;
    session* test_session_ = new session{io_service_};

    void SimulateHandleRead(http::request<http::string_body> request,
                            const boost::system::error_code& ec = boost::system::error_code{},
                            size_t bytes_transferred = 100)
    {
        test_session_->set_request(request);
        test_session_->call_handle_read(ec, bytes_transferred);
    }

    // Helper function to serialize a request object to string
    std::string request_to_string(const http::request<http::string_body>& req) {
      std::ostringstream oss;
      oss << req;
      return oss.str();
    }
};

// Test case for handling a simple GET request
TEST_F(SessionTest, HandleSimpleGET) {
    // 1. Prepare a simple GET request
    http::request<http::string_body> req;
    req.method(http::verb::get);
    req.target("/");
    req.version(11); // HTTP/1.1
    req.set(http::field::host, "localhost");
    req.prepare_payload(); // Important for generating the string representation

    // Convert request to string for the expected echo body
    std::string expected_echo_body = request_to_string(req);

    // 2. Simulate handle_read being called after a successful read
    SimulateHandleRead(req);

    // 3. Check the generated response (res_) in the session
    auto res = test_session_->get_response();
    EXPECT_EQ(res.result(), http::status::ok);
    EXPECT_EQ(res.version(), 11);
    EXPECT_EQ(res[http::field::content_type], "text/plain");
    EXPECT_EQ(res.body(), expected_echo_body);
}

// Test case for handle_read encountering an error
TEST_F(SessionTest, HandleReadError) {
    // 1. Prepare a dummy request (content doesn't matter much here)
    http::request<http::string_body> req;
    req.method(http::verb::get);
    req.target("/");
    req.version(11);

    // 2. Simulate handle_read being called with an error
    // We expect the session to delete itself in this case, so we can't check state after.
    boost::system::error_code ec = boost::asio::error::connection_reset;
    EXPECT_NO_THROW(test_session_->call_handle_read(ec, 0));
}

// Test case for handling a GET request with a specific path
TEST_F(SessionTest, HandleGETWithPath) {
  // 1. Prepare a GET request with a path
  http::request<http::string_body> req;
  req.method(http::verb::get);
  req.target("/api/users?id=123");
  req.version(11);
  req.set(http::field::host, "example.com");
  req.prepare_payload();

  std::string expected_echo_body = request_to_string(req);

  // 2. Simulate handle_read
  SimulateHandleRead(req);

  // 3. Check the response
  auto res = test_session_->get_response();
  EXPECT_EQ(res.result(), http::status::ok);
  EXPECT_EQ(res.version(), 11);
  EXPECT_EQ(res[http::field::content_type], "text/plain");
  EXPECT_EQ(res.body(), expected_echo_body);
}

// Test case for handling a POST request with a body
TEST_F(SessionTest, HandlePOSTRequest) {
  // 1. Prepare a POST request
  http::request<http::string_body> req;
  req.method(http::verb::post);
  req.target("/submit_form");
  req.version(11);
  req.set(http::field::host, "myserver");
  req.set(http::field::content_type, "application/x-www-form-urlencoded");
  req.body() = "name=test&value=123";
  req.prepare_payload(); // Calculates Content-Length

  std::string expected_echo_body = request_to_string(req);

  // 2. Simulate handle_read
  SimulateHandleRead(req);

  // 3. Check the response
  auto res = test_session_->get_response();
  EXPECT_EQ(res.result(), http::status::ok);
  EXPECT_EQ(res.version(), 11);
  EXPECT_EQ(res[http::field::content_type], "text/plain"); // Echo server responds with text/plain
  EXPECT_EQ(res.body(), expected_echo_body);
}

// Test case for handling a request with multiple headers
TEST_F(SessionTest, HandleRequestWithHeaders) {
  // 1. Prepare a request with multiple headers
  http::request<http::string_body> req;
  req.method(http::verb::get);
  req.target("/status");
  req.version(11);
  req.set(http::field::host, "monitor.com");
  req.set(http::field::user_agent, "TestClient/1.0");
  req.set(http::field::accept, "application/json");
  req.prepare_payload();

  std::string expected_echo_body = request_to_string(req);

  // 2. Simulate handle_read
  SimulateHandleRead(req);

  // 3. Check the response
  auto res = test_session_->get_response();
  EXPECT_EQ(res.result(), http::status::ok);
  EXPECT_EQ(res.version(), 11);
  EXPECT_EQ(res[http::field::content_type], "text/plain");
  EXPECT_EQ(res.body(), expected_echo_body);
}

// Test case for handling a request with "Connection: close"
TEST_F(SessionTest, HandleRequestConnectionClose) {
  // 1. Prepare a request asking to close the connection
  http::request<http::string_body> req;
  req.method(http::verb::get);
  req.target("/logout");
  req.version(11);
  req.set(http::field::host, "secure.com");
  req.set(http::field::connection, "close"); // Request connection close
  req.prepare_payload();

  std::string expected_echo_body = request_to_string(req);

  // 2. Simulate handle_read
  SimulateHandleRead(req);

  // 3. Check the response
  auto res = test_session_->get_response();
  EXPECT_EQ(res.result(), http::status::ok);
  EXPECT_EQ(res.version(), 11);
  EXPECT_EQ(res[http::field::content_type], "text/plain");
  EXPECT_EQ(res.body(), expected_echo_body);
}
